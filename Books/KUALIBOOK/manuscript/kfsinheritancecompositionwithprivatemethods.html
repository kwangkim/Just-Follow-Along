<h2>KFS Inheritance/Composition with Private Methods</h2>
<h3>The Problem Scenario</h3>Suppose an instance arrives where you need to change the functionality of KFS slightly, but the method you want to override is declared private. Need an example? I have one. Read on.<p><h3>Digester and Namespace Validation</h3>By default, Digester within KFS has namespace validation off. Suppose you want to turn it on. Now you run into exactly such issue.<br /><pre>package edu.arizona.kfs.sys.batch;<br />...<br />...<br />public class XmlBatchInputFileTypeBase extends org.kuali.kfs.sys.batch.XmlBatchInputFileTypeBase {<br />    /**<br />     * @see org.kuali.kfs.sys.batch.BatchInputFileType#parse(byte[])<br />     */<br />    public Object parse(byte[] fileByteContent) throws ParseException {<br />        if (fileByteContent == null) {<br />            LOG.error("an invalid(null) argument was given");<br />            throw new IllegalArgumentException("an invalid(null) argument was given");<br />        }</pre></p><p>        // handle zero byte contents, xml parsers don't deal with them well<br />        if (fileByteContent.length == 0) {<br />            LOG.error("an invalid argument was given, empty input stream");<br />            throw new IllegalArgumentException("an invalid argument was given, empty input stream");<br />        }</p><p>        // validate contents against schema<br />        ByteArrayInputStream validateFileContents = new ByteArrayInputStream(fileByteContent);<br />        validateContentsAgainstSchema(getSchemaLocation(), validateFileContents);</p><p>        // setup digester for parsing the xml file</p><p>        Digester digester = null;<br />        try {<br />            Method digesterMethod = getClass().getDeclaredMethod("buildDigester", String.class, String.class);<br />            m.setAccessible(true); // Private? Who cares?! I sure don't.<br />            m.invoke(this, getSchemaLocation(), getDigestorRulesFileName());<br />        }<br />        catch(IllegalAccessExption e) {<br />            // Not since it's accessible now.<br />        }<br />        catch(InvocationTargetException e) {<br />            // Something else naughty happened<br />        }</p><p><br />        Object parsedContents = null;<br />        try {<br />            ByteArrayInputStream parseFileContents = new ByteArrayInputStream(fileByteContent);<br />            parsedContents = digester.parse(validateFileContents);<br />        }<br />        catch (Exception e) {<br />            LOG.error("Error parsing xml contents", e);<br />            throw new ParseException("Error parsing xml contents: " + e.getMessage(), e);<br />        }</p><p>        return parsedContents;    <br />    }</p><p>}<br />The trick is in<br /><pre><br />        Digester digester = null;<br />        try {<br />            Method digesterMethod = getClass().getDeclaredMethod("buildDigester", String.class, String.class);<br />            m.setAccessible(true); // Private? Who cares?! I sure don't.<br />            m.invoke(this, getSchemaLocation(), getDigestorRulesFileName());<br />        }<br />        catch(IllegalAccessExption e) {<br />            // Not since it's accessible now.<br />        }<br /></pre><br />By calling <tt>m.setAccessible(true)</tt>, we can still call the private method. many call this a hack because it ignores the <b>private</b> access. I think many people are confused in what that means. The control is rather just for managing scope and maintaining OO encapsulation. These directives are not intended for security. They are intended to enforce OO. If we wanted to restrict method access, a <tt>SecurityManager</tt> implementation would be more appropriate. IMHO, this is an entirely acceptable thing to do <i>in this situation</i>. That being that we are being restricted by a flaw in the API from doing something we should be allowed to do. This happens often, and is a much better alternative than duplicating code.</p><p>With this, we can get away with extending code and overriding behavior.<div></div></p>