<h2>KISmet - Game Changer: Structuring the Project to Manage Database Changes with Liquibase</h2>
Structuring your project to handle configuration management of your project RDBMS can probably be the most difficult part of managing your project. If you plan to use <a href="http://www.liquibase.org">Liquibase</a> to manage your database migrations, then this is even more the case. At the <a href="http://www.arizona.edu">University of Arizona</a>, we first followed the instructions laid out by this <a href="http://www.liquibase.org/tutorial-using-oracle">tutorial</a> (<a href="http://www.liquibase.org/tutorial-using-oracle">Tutorial Using Oracle</a>) since we're using Oracle.<p>We retain in our methodology much from that article, but rather than explain the differences, I'll just explain what we did.</p><p><h3>The University of Arizona Liquibase Methodology in a Nutshell</h3>The goals we wanted to solve with simplified data migration using <a href="http://www.liquibase.org">Liquibase</a> are:<ul><li>Structure for isolating database changes.</li><li>Integrates with a process that versions a database from SVN, Jira, and Continuous Integration.</li><li>Coupled database version with application version.</li><li>Integrates with a process that facilitates rollback, update, and complete schema rebuilds.</li></ul><br /><h3>Structure for Isolating Database Changes</h3>A project was created at <a href="http://www.arizona.edu">University of Arizona</a> called <i>kfs-cfg-dbs</i>. Within that project is where we created the structure to manage out database migrations. We followed the example outlined in <a href="http://www.liquibase.org/tutorial-using-oracle">Tutorial Using Oracle</a>. We found that we can create two paths. One path is for update (<tt>update/</tt>), and the other path is for building the latest schema entirely (<tt>latest/</tt>).<br /><h3>latest/</h3><p>Here, we followed the convention of using 3-character paths according to the changelog content.</p><br /><table style="margin:0 0 0 0;padding:0 0 0 0">  <tr>    <th>Pathname</th>  <th>Content</th>  </tr>  <tr>    <td>cst</td>    <td>constraint-related changelog</td>  </tr>  <tr>    <td>dat</td>    <td>table-related changelog</td>  </tr>  <tr>    <td>idx</td>    <td>index-related changelog</td>  </tr>  <tr>    <td>seq</td>    <td>sequence-related changelog</td>  </tr>  <tr>    <td>tab</td>    <td>table-related changelog</td>  </tr>  <tr>    <td>vw</td>    <td>view-related changelog</td>  </tr></table><br /><h3>constraints.xml</h3>During our database migrations, we load schema changes and data changes. These data changes can sometimes effect constraints. For full schema rebuilds, we load constraints last to allow data loads to process faster. Therefore, we separate our constraint changelog information into its own file to run last.<br /><pre>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;<br />&lt;databaseChangeLog xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.9&quot;<br />                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />                   xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.9 http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-1.9.xsd&quot;&gt;<br />    &lt;include file=&quot;latest/cst/LD_EXP_TRNFR_DOC_T.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/cst/FP_PMT_MTHD_T.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/cst/FP_PMT_MTHD_CHART_T.xml&quot; /&gt;<br />&lt;/databaseChangeLog&gt;</pre></p><p>Notice that entries are simply includes that point to files associated by table name in the <tt>cst/</tt> directory within the <tt>latest/</tt> path. For example, <tt>latest/cst/LD_EXP_TRNFR_DOC_T.xml</tt> refers to constraints on the <tt>LD_EXP_TRNFR_DOC_T</tt> table. Because <tt>cst/</tt> is taken from <tt>latest/</tt> we know that this file relates to new schema migrations. 100% of the time, includes in <tt>constraints.xml</tt> will point to <tt>latest</tt>. That is our convention.</p><p><h3>data.xml</h3>Similarly to <tt>constraints.xml</tt>, <tt>data.xml</tt> has entries to data by table-name in <tt>latest/</tt> for new schema migrations. Here is ours:</p><p><pre><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;<br />&lt;databaseChangeLog xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.9&quot;<br />                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />                   xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.9 http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-1.9.xsd&quot;&gt;<br />    &lt;include file=&quot;latest/dat/FP_PMT_MTHD_T.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/dat/FP_PMT_MTHD_CHART_T.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/dat/KREW.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/dat/KRIM.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/dat/KRIM3.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/dat/GL_OFFSET_DEFN_T.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/dat/KRIM2.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/dat/KRNS_PARM_T.xml&quot; /&gt;<br /></pre><br /><h3>install.xml</h3>Anything that needs to be migrated before data and constraints is added to the <tt>install.xml</tt>. It follows exactly the same convention as the previous two:</p><p><pre><br />    &lt;include file=&quot;latest/tab/FP_PRCRMNT_LVL3_ADD_ITEM_T.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/tab/FP_PRCRMNT_LVL3_FUEL_T.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/tab/FP_PRCRMNT_CARD_HLDR_DTL_T.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/tab/FP_PRCRMNT_CARD_TRN_T.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/tab/FP_PRCRMNT_CARD_HLDR_LD_T.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/tab/PDP_SHIPPING_INV_TRACKING_T.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/seq/ERROR_CERT_ID_SEQ.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/seq/CM_CPTLAST_AWARD_HIST_NBR_SEQ.xml&quot; /&gt;<br />    &lt;include file=&quot;latest/seq/PUR_PDF_LANG_ID.xml&quot; /&gt;<br /></pre><br /><h3>update/</h3>The update changelog is responsible for database migrations on existing schemas. It simply updates a schema already in use, so these are all changes.<br /><pre><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;<br />&lt;databaseChangeLog xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.9&quot;<br />                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />                   xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.9 http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-1.9.xsd&quot;&gt;<br />    &lt;include file=&quot;update/KITT-958.xml&quot; /&gt;<br />&lt;/databaseChangeLog&gt;</pre></p><p>The <tt>update.xml</tt> refers to files in the <tt>update/</tt> path which contains files associated by Jira Issue #. By this convention, we know that <tt>update/KITT-958.xml</tt> contains a change in this version for KITT-958. This is how we get our Jira coupling. Using this convention, we can migrate perpetually and let Jira handle linkage with our data migration/issue management.</p><p><h3>Integrates with a process that versions a database from SVN, Jira, and Continuous Integration.</h3>I have already shown how this works with Jira, but how do we get exclusive database versions? We use SVN to handle changelog ids for us. Changelog ids are what <a href="http://www.liquibase.org/">Liquibase</a> uses to identify which changes are to be run. Each change gets its own id, to identify it apart from others. In order to lessen developer overhead, we simply use the <tt>$Revision$</tt> keyword from SVN.</p><p><pre><br />&lt;databaseChangeLog xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.9&quot;<br />                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />                   xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.9 http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-1.9.xsd&quot;&gt;<br />    &lt;changeSet id=&quot;$Revision$&quot; author=&quot;$Author&quot; &gt;<br />        &lt;comment&gt;Adding a new kim type of patisserie and a new eclair baker role. Yum!!&lt;/comment&gt;<br /></pre></p><p>This will put a new revision id with each checkin. We also use <tt>$Author$</tt> to identify the person that made the change. This convention falls apart when a person commits more than one changelog at a time. Then two changelogs have the same id. This will cause problems.</p><p>Part of our methodology is the concept of <i>one-change-per-checkin</i>. That is, when creating a changelog for <tt>update/</tt>, we put all changes relating to KITT-958 for this release into a single changeset in our KITT-958.xml. If we have changes for another issue (KITT-959), then we put changes in KITT-959.xml. That is fine. It is crucial to understand that only one of these files gets checked in at a time though. That is, first, commit KITT-958.xml, then KITT-959.xml. The reason is that when one gets committed, it gets a revision number. Then, when the next one is committed, it gets a different revision number. This helps us keep a consistent set of changelog ids, and also prevent changelogs from stepping on each other.</p><p><h3>Integrates with a process that facilitates rollback, update, and complete schema rebuilds.</h3>I will explain this in more detail when I discuss testing changes to data migration. I will say though that <a href="http://www.liquibase.org">Liquibase</a> supports rollback of changes. Using our configuration management system, this allows us to couple data migrations with a release of KFS. We can suddenly move between versions very easily by undoing what we have done. In most cases, <a href="http://www.liquibase.org">Liquibase</a> can automatically rollback changes by analyzing different patterns based on the refactoring. Some cases, this is very difficult though (consult the <a href="http://www.liquibase.org">Liquibase</a> manual for more details on what does and doesn't auto-rollback). One example is data-related migrations. When inserting data, liquibase cannot understand how to undo an insert or an update of a record. For this, changelogs have a rollback directive to explicitly define a rollback pattern.</p><p><pre><br />&lt;databaseChangeLog xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.9&quot;<br />                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />                   xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.9 http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-1.9.xsd&quot;&gt;<br />    &lt;changeSet id=&quot;$Revision$&quot; author=&quot;$Author&quot; &gt;<br />        &lt;comment&gt;Adding a new kim type of patisserie and a new eclair baker role. Yum!!&lt;/comment&gt;<br />    &lt;sql splitStatements=&quot;false&quot; endDelimiter=&quot;&quot;&gt;&lt;![CDATA[<br />declare <br />ktyp_id krim_typ_t.kim_typ_id%TYPE;<br />BEGIN<br />    INSERT INTO KRIM_TYP_T <br />    (KIM_TYP_ID, OBJ_ID, VER_NBR, NM, SRVC_NM, ACTV_IND, NMSPC_CD) VALUES <br />    (KRIM_TYP_ID_S.NEXTVAL,'SYS_GUID()', 1,'Patisserie',null,'Y','KUALI')<br />    RETURNING kim_typ_id into ktyp_id;</pre></p><p>    INSERT INTO KRIM_ROLE_T <br />    (ROLE_ID,OBJ_ID,VER_NBR,ROLE_NM,NMSPC_CD,DESC_TXT, KIM_TYP_ID, ACTV_IND) VALUES <br />    (KRIM_ROLE_ID_S.NEXTVAL,SYS_GUID(),1,'Eclair Baker','KUALI',null,ktyp_id,'Y');<br />END;<br />]]&gt;<br />    &lt;/sql&gt;<br />    &lt;rollback&gt;<br />      &lt;sql&gt;&lt;![CDATA[<br />delete from KRIM_TYP_T where NM = 'Patisserie';</p><p>delete from KRIM_ROLE_T where ROLE_NM = 'Eclair Baker';<br />]]&gt;<br />      &lt;/sql&gt;<br />    &lt;/rollback&gt;<br /><br /><h3>Case Study: Adding a Data-Only Change</h3>Here is a screencast on how to use liquibase to migrate database changes using the University of Arizona's methodology for change management. Includes an example on making a data related change.</p><p><embed allowfullscreen="true" src="http://www.youtube.com/v/PvEhn8kzDww&amp;hl=en_US&amp;fs=1&amp;" type="application/x-shockwave-flash" wmode="transparent" allowscriptaccess="never" height="385" width="480"></embed></p><p><h3>Looking Ahead</h3>Be sure to read my next blog entry which will describe how to test this change against a database using rollbacks.<div></div></p>