<h2>KFS Inheritance/Composition with Private Methods</h2>
<h3>The Problem Scenario</h3>Suppose an instance arrives where you need to change the functionality of KFS slightly, but the method you want to override is declared private. Need an example? I have one. Read on.</p><p><h3>Digester and Namespace Validation</h3>By default, Digester within KFS has namespace validation off. Suppose you want to turn it on. Now you run into exactly such issue. Below is the original code from the <i>XmlBatchInputFileTypeBase</i><br />
<pre>
...
...
public class XmlBatchInputFileTypeBase extends BatchInputFileTypeBase {
    /**
     * @see org.kuali.kfs.sys.batch.BatchInputFileType#parse(byte[])<br />     
     */<br />    
     public Object parse(byte[] fileByteContent) throws ParseException {
         if (fileByteContent == null) {
             LOG.error("an invalid(null) argument was given");
             throw new IllegalArgumentException("an invalid(null) argument was given");
         }

         // handle zero byte contents, xml parsers don't deal with them well
         if (fileByteContent.length == 0) {<br />            LOG.error("an invalid argument was given, empty input stream");<br />            throw new IllegalArgumentException("an invalid argument was given, empty input stream");<br />        }</p><p>        // validate contents against schema<br />        ByteArrayInputStream validateFileContents = new ByteArrayInputStream(fileByteContent);<br />        validateContentsAgainstSchema(getSchemaLocation(), validateFileContents);</p><p>        // setup digester for parsing the xml file</p><p>        Digester digester = buildDigester(getSchemaLocation());</p><p>        Object parsedContents = null;<br />        try {<br />            ByteArrayInputStream parseFileContents = new ByteArrayInputStream(fileByteContent);<br />            parsedContents = digester.parse(validateFileContents);<br />        }<br />        catch (Exception e) {<br />            LOG.error("Error parsing xml contents", e);<br />            throw new ParseException("Error parsing xml contents: " + e.getMessage(), e);<br />        }</p><p>        return parsedContents;    <br />    }</p><p>}<br />The problem is with <i>buildDigester(getSchemaLocation())</i>. <i>XmlBatchInputFileTypeBase#buildDigester()</i> is declared private. That is, if one tries to extend <i>XmlBatchInputFileTypeBase</i>, you not only cannot override the <i>buildDigester()</i> method, but you can't call it from an inheriting class either.</p><p>We would love to do<pre>        Digester digester = buildDigester(getSchemaLocation());</pre><br />But we can't. The alternative is to use reflection and call the private <i>buildDigester</i> method anyway.</p><p>Here's an example:<pre>package edu.arizona.kfs.sys.batch;<br />...<br />...<br />public class XmlBatchInputFileTypeBase extends org.kuali.kfs.sys.batch.XmlBatchInputFileTypeBase {<br />    /**<br />     * @see org.kuali.kfs.sys.batch.BatchInputFileType#parse(byte[])<br />     */<br />    public Object parse(byte[] fileByteContent) throws ParseException {<br />        if (fileByteContent == null) {<br />            LOG.error("an invalid(null) argument was given");<br />            throw new IllegalArgumentException("an invalid(null) argument was given");<br />        }</pre></p><p>        // handle zero byte contents, xml parsers don't deal with them well<br />        if (fileByteContent.length == 0) {<br />            LOG.error("an invalid argument was given, empty input stream");<br />            throw new IllegalArgumentException("an invalid argument was given, empty input stream");<br />        }</p><p>        // validate contents against schema<br />        ByteArrayInputStream validateFileContents = new ByteArrayInputStream(fileByteContent);<br />        validateContentsAgainstSchema(getSchemaLocation(), validateFileContents);</p><p>        // setup digester for parsing the xml file</p><p>        Digester digester = null;<br />        try {<br />            Method digesterMethod = getClass().getDeclaredMethod("buildDigester", String.class, String.class);<br />            m.setAccessible(true); // Private? Who cares?! I sure don't.<br />            m.invoke(this, getSchemaLocation(), getDigestorRulesFileName());<br />        }<br />        catch(IllegalAccessExption e) {<br />            // Not since it's accessible now.<br />        }<br />        catch(InvocationTargetException e) {<br />            // Something else naughty happened<br />        }</p><p>        if (digester == null) {<br />        // throw some exception because this is very bad<br />        }</p><p>        digester.setNamespaceAware(true); // Enabling the namespace checking! Yeay!</p><p><br />        Object parsedContents = null;<br />        try {<br />            ByteArrayInputStream parseFileContents = new ByteArrayInputStream(fileByteContent);<br />            parsedContents = digester.parse(validateFileContents);<br />        }<br />        catch (Exception e) {<br />            LOG.error("Error parsing xml contents", e);<br />            throw new ParseException("Error parsing xml contents: " + e.getMessage(), e);<br />        }</p><p>        return parsedContents;    <br />    }</p><p>}<br />The trick is in<br /><pre><br />        Digester digester = null;<br />        try {<br />            Method digesterMethod = getClass().getDeclaredMethod("buildDigester", String.class, String.class);<br />            m.setAccessible(true); // Private? Who cares?! I sure don't.<br />            m.invoke(this, getSchemaLocation(), getDigestorRulesFileName());<br />        }<br />        catch(IllegalAccessExption e) {<br />            // Not since it's accessible now.<br />        }<br /></pre><br />By calling <i>m.setAccessible(true)</i>, we can still call the private method. many call this a hack because it ignores the <b>private</b> access. I think many people are confused in what that means. The control is rather just for managing scope and maintaining OO encapsulation. These directives are not intended for security. They are intended to enforce OO. If we wanted to restrict method access, a <i>SecurityManager</i> implementation would be more appropriate. IMHO, this is an entirely acceptable thing to do <i>in this situation</i>. That being that we are being restricted by a flaw in the API from doing something we should be allowed to do. This happens often, and is a much better alternative than duplicating code.</p><p>Then later, we append our changes to the digester with...<br /><pre><br />        digester.setNamespaceAware(true); // Enabling the namespace checking! Yeay!<br /></pre><br />With this, we can get away with extending code and overriding behavior (setting namespace awareness).<div></div></p>